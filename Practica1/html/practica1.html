
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Practica 1</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-02-06"><meta name="DC.source" content="practica1.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Practica 1</h1><!--introduction--><p>Teresa Gonz&aacute;lez y Miguel Oleo</p><p>LE1 Grupo 3</p><p>Entrega practica 1 PDS.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Fichero</a></li><li><a href="#2">Muestreo</a></li><li><a href="#3">Apartado a)</a></li><li><a href="#4">Apartado b)</a></li><li><a href="#5">Apartado c)</a></li><li><a href="#6">Apartado d)</a></li><li><a href="#7">Apartado e)</a></li><li><a href="#8">Apartado f)</a></li><li><a href="#9">Apartado g)</a></li><li><a href="#10">Cuantificacion</a></li><li><a href="#11">Apartado a)</a></li><li><a href="#12">Apartado b)</a></li><li><a href="#13">Apartado c)</a></li><li><a href="#14">Apartado d)</a></li><li><a href="#15">Apartado e)</a></li><li><a href="#16">Apartado f)</a></li><li><a href="#17">Apartado g)</a></li><li><a href="#18">Apartado h)</a></li><li><a href="#19">Apartado i)</a></li><li><a href="#20">Apartado j)</a></li><li><a href="#21">Apartado k)</a></li><li><a href="#22">Apartado l)</a></li></ul></div><h2 id="1">Fichero</h2><p>Cargamos el fichero y hacemos dos plots para ver con que se&ntilde;ales estamos trabajando.</p><pre class="codeinput">load(<span class="string">'PDS_P1_LE1_G3.mat'</span>);

figure();
plot(t*1000,x);
xlabel(<span class="string">'t en ms'</span>);
ylabel(<span class="string">'x(t)'</span>);
figure()
plot(t_k*1000,k)
xlabel(<span class="string">'t_k en ms'</span>);
ylabel(<span class="string">'k(t_k)'</span>);
</pre><img vspace="5" hspace="5" src="practica1_01.png" alt=""> <img vspace="5" hspace="5" src="practica1_02.png" alt=""> <h2 id="2">Muestreo</h2><h2 id="3">Apartado a)</h2><p>Frecuencia de muestreo [muestras/segundo] = (tiempo que dura la se&ntilde;al/numero de muestras)^-1</p><pre class="codeinput">f_s = (max(t)/size(x,1))^-1;
</pre><h2 id="4">Apartado b)</h2><p>El teorema de Nyquist nos indica que, para que no haya interferencia intersimb&oacute;lica al muestrear, la frecuencia de muestreo debe ser mayor o igual a dos veces el ancho de banda de la se&ntilde;al.</p><p>Para sacar el ancho de banda de la se&ntilde;al, realizamos la transformada de Fourier de dicha se&ntilde;al y la representamos. Para ello tambi&eacute;n debemos generar un vector de frecuencias. Una vez ya respresentado el espectro de la se&ntilde;al, podemos obtener la m&aacute;xima componente en frecuencia.</p><p>De la grafica sacamos ancho de banda = 20.5 KHz</p><pre class="codeinput">X = (fft(x,length(x)))/length(x);
f_x = linspace(-f_s/2,f_s/2,length(X));
figure()
plot(f_x/1000,fftshift(abs(X)));
xlabel(<span class="string">'Frecuencia en KHz'</span>);
ylabel(<span class="string">'X(f)'</span>);
f_n = 2*20500;
</pre><img vspace="5" hspace="5" src="practica1_03.png" alt=""> <h2 id="5">Apartado c)</h2><p>En este apartado cambiaremos al frecuencia de muestreo a tres medios la frecuencia m&iacute;nima (la obtenida por el teor&iacute;ma de Nyquist en el apartado anterior). Para muestrear la se&ntilde;al a esta nueva frecuencia, utilizaremos la funcion interp1.</p><p>Al representar gr&aacute;ficamente podemos observar que el espectro de la se&ntilde;al con esta nueva frecuencia de muestreo, es la misma que la original. Esto se debe a que no incumplimos el teorema de Nyquist.</p><pre class="codeinput">fs1 = (3*f_n)/2;
t1 = t(1):1/fs1:t(end);
g = interp1(t,x,t1,<span class="string">'spline'</span>);

G = (fft(g,length(g)))/length(g);
f_g = linspace(-fs1/2,fs1/2,length(G));
figure()
plot(f_g/1000,fftshift(abs(G)));
xlabel(<span class="string">'Frecuencia en KHz'</span>);
ylabel(<span class="string">'G(f)'</span>);
</pre><img vspace="5" hspace="5" src="practica1_04.png" alt=""> <h2 id="6">Apartado d)</h2><p>En este apartado repetiremos el procedimiento del apartado c). Esta vez la frecuencia de muestreo ser&aacute; dos tercios de la frecuencia de Nyquist.</p><p>Antes de calcular nada, podr&iacute;amos decir firmemente que la se&ntilde;al muestreada no ser&aacute; la misma que la original, ya que no comple el teorema de Nyquist.</p><p>Como se puede observar, el espectro de esta se&ntilde;al no es equivalente al de la original. Esto se debe a que se produce Aliasing, ya que no hemos cumplido el teorema de Nyquist.</p><pre class="codeinput">fs2 = (2*f_n)/3;
t2 = t(1):1/fs2:t(end);
h = interp1(t,x,t2,<span class="string">'spline'</span>);

H = (fft(h,length(h)))/length(h);
f_h = linspace(-fs2/2,fs2/2,length(H));
figure()
plot(f_h/1000,fftshift(abs(H)));
xlabel(<span class="string">'Frecuencia en KHz'</span>);
ylabel(<span class="string">'H(f)'</span>);
</pre><img vspace="5" hspace="5" src="practica1_05.png" alt=""> <h2 id="7">Apartado e)</h2><p>Vamos a emplear un subplot para representar los espectros de la se&ntilde;al original y las dos se&ntilde;ales con las frecuencias de muestreo cambiadas. Se puede ver claramente en la &uacute;ltima, que al no cumplir el teorema de Nyquist, no obtenemos la misma se&ntilde;al.</p><pre class="codeinput">figure()
subplot(3,1,1);
plot(f_x/1000,fftshift(abs(X)));
hold <span class="string">on</span>
xlabel(<span class="string">'frecuencia en KHz'</span>);
ylabel(<span class="string">'X(f)'</span>);
xlim([-30 30]);
subplot(3,1,2);
plot(f_g/1000,fftshift(abs(G)));
xlabel(<span class="string">'frecuencia en KHz'</span>);
ylabel(<span class="string">'G(f)'</span>);
xlim([-30 30]);
subplot(3,1,3);
plot(f_h/1000,fftshift(abs(H)));
xlabel(<span class="string">'frecuencia en KHz'</span>);
ylabel(<span class="string">'H(f)'</span>);
xlim([-30 30]);
</pre><img vspace="5" hspace="5" src="practica1_06.png" alt=""> <img vspace="5" hspace="5" src="practica1_07.png" alt=""> <h2 id="8">Apartado f)</h2><p>Se puede observar una leve potencia a lo largo del espectro. Esto se debe a que hay ruido presente en el sistema. Se ve sobre todo ruido entre las componentes de la tercera gr&aacute;fica. Tambien hay ruido intersimb&oacute;lico (presente en la tercera gr&aacute;fica) y de interpolaci&oacute;n, presente en todas las se&ntilde;ales. Este &uacute;ltimo se debe a que, al tener datos discretos de las se&ntilde;ales, al hacer el plot, hay una interpolaci&oacute;n.</p><h2 id="9">Apartado g)</h2><p>Una vez m&aacute;s, se puede ver que la tercera se&ntilde;al, no se puede recuperar la misma informaci&oacute;n que la se&ntilde;al original debido al Aliasing.</p><pre class="codeinput">figure()
subplot(3,1,1)
plot(t*1000,x);
hold <span class="string">on</span>
xlabel(<span class="string">'tiempo en ms'</span>)
ylabel(<span class="string">'x(t)'</span>)
subplot(3,1,2);
plot(t1*1000,g);
hold <span class="string">on</span>
xlabel(<span class="string">'tiempo en ms'</span>)
ylabel(<span class="string">'g(t)'</span>)
subplot(3,1,3);
plot(t2*1000,h);
hold <span class="string">on</span>
xlabel(<span class="string">'tiempo en ms'</span>)
ylabel(<span class="string">'h(t)'</span>)
</pre><img vspace="5" hspace="5" src="practica1_08.png" alt=""> <img vspace="5" hspace="5" src="practica1_09.png" alt=""> <h2 id="10">Cuantificacion</h2><h2 id="11">Apartado a)</h2><p>Los niveles de cuantificaci&oacute;n totales son 2^(B), siendo este n&uacute;mero el numero el m&aacute;ximo de combinaciones disponibles con B bits totales (signo, enteros y decimales).</p><h2 id="12">Apartado b)</h2><p>La magnitud del salto entre dos niveles de cuantificaci&oacute;n consecutivos es 1/(2^D), siendo esta la distancia entre dos niveles de cuantificaci&oacute;n de la parte decimal D, puesto que es el m&iacute;nimo salto consecutivo posible (entre dos bits enteros hay 2^D bitsdecimales).</p><h2 id="13">Apartado c)</h2><p>El rango de cuantificaci&oacute;n m&aacute;ximo es de [-2^(B-D),(2^D)-1] hasta [2^(B-D-1)-1, (2^D)-1], siendo B el n&uacute;mero total de bits, D bits decimales y B-D bits enteros, y teniendo en cuenta en el rango que los bits enteros tienen signo, pero los decimales no tienen signo.</p><h2 id="14">Apartado d)</h2><p>Minimo error = 0. (suponemos que no se comete ning&uacute;n error) Maximo error = 1/2^D*2= 1/2^(D+1, ya que el mayor error cometido es cuando se cuantifica en medio de un nivel de cuantificaci&oacute;n (DistanciaEntre2NivelesConsecutivos/2).</p><h2 id="15">Apartado e)</h2><p>Usando las f&oacute;rmulas obtenidas, para B=5 y D=3: Niveles de cuantificaci&oacute;n: 32 Salto entre niveles: 1/16 Nivel Max: -4,7 ---- Nivel minimo: 1,7 Rango de Error: (0 - 1/32)</p><h2 id="16">Apartado f)</h2><p>Se cuantifica utilizando la f&oacute;rmulas del enunciado palabras con B=4 (1 bit de signo, 3 bits enteros y 0 bits decimales) y D=0. Primero se genera la escala de cuantificaci&oacute;n y posteriormente se cuantifica la se&ntilde;al k(t) que se facilita en la pr&aacute;ctica.</p><pre class="codeinput">q1 = quantizer(<span class="string">'fixed'</span>,<span class="string">'round'</span>,<span class="string">'saturate'</span>,[4,0]);
Ks30 = num2bin(q1,k);
</pre><h2 id="17">Apartado g)</h2><p>Se repite el mismo proceso esta vez con B=4 (1 bit de signo, 1 bit entero y 2 bits decimales) y D=2.</p><pre class="codeinput">q2 = quantizer(<span class="string">'fixed'</span>,<span class="string">'round'</span>,<span class="string">'saturate'</span>,[4,2]);
Ks12 = num2bin(q2,k);
</pre><pre class="codeoutput">Warning: 901 overflow(s) occurred in the fi quantize operation. 
</pre><h2 id="18">Apartado h)</h2><p>Se repite el mismo proceso esta vez con B=6 (1 bit de signo, 3 bits enteros y 2 bits decimales) y D=2.</p><pre class="codeinput">q3 = quantizer(<span class="string">'fixed'</span>,<span class="string">'round'</span>,<span class="string">'saturate'</span>,[6,2]);
Ks32 = num2bin(q3,k);
</pre><h2 id="19">Apartado i)</h2><p>Se repite el mismo proceso esta vez con B=6 (1 bit de signo, 5 bits enteros y 0 bits decimales) y D=0.</p><pre class="codeinput">q4 = quantizer(<span class="string">'fixed'</span>,<span class="string">'round'</span>,<span class="string">'saturate'</span>,[6,0]);
Ks50 = num2bin(q4,k);
</pre><h2 id="20">Apartado j)</h2><p>Se analiza en el dominio del tiempo las diferencias entre la se&ntilde;al original y las se&ntilde;ales cuantificadas como valores decimales (ya que los valores binarios tienen que tener una interpretaci&oacute;n decimal para ser v&aacute;lidos). Para las se&ntilde;ales cuantificadas en valor decimal se nos facilita una funci&oacute;n.</p><p>En la representaci&oacute;n temporal de las se&ntilde;ales se observan ligeras diferencias. En concreto se puede ver muy claramente que la se&ntilde;al Ks12 se parece a la se&ntilde;al original.</p><pre class="codeinput">figure()
subplot(5,1,1)
plot(t_k,k);
hold <span class="string">on</span>
xlabel(<span class="string">'tiempo en ms'</span>)
ylabel(<span class="string">'k(t)'</span>)

subplot(5,1,2)
plot(t_k,bin2num(q1,Ks30));
hold <span class="string">on</span>
xlabel(<span class="string">'tiempo en ms'</span>)
ylabel(<span class="string">'ks30(t)'</span>)

subplot(5,1,3)
plot(t_k,bin2num(q2,Ks12));
hold <span class="string">on</span>
xlabel(<span class="string">'tiempo en ms'</span>)
ylabel(<span class="string">'ks12(t)'</span>)

subplot(5,1,4)
plot(t_k,bin2num(q3,Ks32));
hold <span class="string">on</span>
xlabel(<span class="string">'tiempo en ms'</span>)
ylabel(<span class="string">'ks32(t)'</span>)

subplot(5,1,5)
plot(t_k,bin2num(q4,Ks50));
hold <span class="string">on</span>
xlabel(<span class="string">'tiempo en ms'</span>)
ylabel(<span class="string">'ks50(t)'</span>)
</pre><img vspace="5" hspace="5" src="practica1_10.png" alt=""> <h2 id="21">Apartado k)</h2><p>Se pretende calcular el error cuadr&aacute;tico medio (ECM) cometido en cada cuantificaci&oacute;n de las distintas se&ntilde;ales, para facilitar la operaci&oacute;n se ha creado la funci&oacute;n ECM en un fichero aparte, al cual se le llama desde el main principal y muestra por pantalla el ECM de cada se&ntilde;al cuantificada con respecto a la original.</p><p>La funci&oacute;n ECM recibe como par&aacute;metros k original y KsXX cuantificada para cada apartado anterior, y devuelve el valor del ECM. Igual que vimos en las graficas, la funcion nos indica que Ks12 tiene una tasa de error muy superior al resto.</p><pre class="codeinput"><span class="comment">% error Ks30</span>

disp(<span class="string">'Error Ks30'</span>);
disp(ECM(k,bin2num(q1,Ks30)));

<span class="comment">% error Ks12</span>

disp(<span class="string">'Error Ks12'</span>);
disp(ECM(k,bin2num(q2,Ks12)));

<span class="comment">% error Ks32</span>

disp(<span class="string">'Error Ks32'</span>);
disp(ECM(k,bin2num(q3,Ks32)));

<span class="comment">% error Ks50</span>

disp(<span class="string">'Error Ks50'</span>);
disp(ECM(k,bin2num(q4,Ks50)));
</pre><pre class="codeoutput">Error Ks30
    0.1153

Error Ks12
    2.9667

Error Ks32
    0.0090

Error Ks50
    0.1153

</pre><h2 id="22">Apartado l)</h2><p>Se pretende analizar el espectro de la se&ntilde;al original y dos de sus se&ntilde;ales cuantificadas (tras pasar los valores binarios a decimales para su representaci&oacute;n). Inicialmente calculamos la frecuencia de muestreo correspondiente para acotar el eje de frecuencias y calculamos los m&oacute;dulos de las transformadas de Fourier de las se&ntilde;ales en cuesti&oacute;n.</p><p>Por &uacute;ltimo, volvemos a hacer incapi&eacute; en como al cuantificar se produce un error. En la se&ntilde;al Ks30 se observa un error pero leve. Sin embargo, se puede observar que el espectro de Ks12 es muy distinto al original.</p><p>Los picos que se pueden observar a lo largo del espectro (los que no aparecen en la se&ntilde;al original), se deben a errores en la cuantificaci&oacute;n.</p><pre class="codeinput">f_sk = (max(t_k)/size(k,1))^-1;
K = (fft(k,length(k)))/length(k);
f_k = linspace(-f_sk/2,f_sk/2,length(K));
Ks30f = (fft(bin2num(q1,Ks30),length(bin2num(q1,Ks30))))/length(bin2num(q1,Ks30));
Ks12f = (fft(bin2num(q2,Ks12),length(bin2num(q2,Ks12))))/length(bin2num(q2,Ks12));

figure()
subplot(3,1,1);
plot(f_k/1000,fftshift(abs(K)));
hold <span class="string">on</span>
xlabel(<span class="string">'frecuencia en Khz'</span>)
ylabel(<span class="string">'|K(f)|'</span>)
subplot(3,1,2);
plot(f_k/1000,fftshift(abs(Ks30f)));
hold <span class="string">on</span>
xlabel(<span class="string">'frecuencia en Khz'</span>)
ylabel(<span class="string">'|Ks30(f)|'</span>)
subplot(3,1,3);
plot(f_k/1000,fftshift(abs(Ks12f)));
hold <span class="string">on</span>
xlabel(<span class="string">'frecuencia en Khz'</span>)
ylabel(<span class="string">'|Ks12(f)|'</span>)
</pre><img vspace="5" hspace="5" src="practica1_11.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Practica 1
% 
% Teresa González y Miguel Oleo
% 
% LE1 Grupo 3
% 
% Entrega practica 1 PDS.
%
%% Fichero
% 
% Cargamos el fichero y hacemos dos plots para ver con que señales estamos
% trabajando.

load('PDS_P1_LE1_G3.mat');

figure();
plot(t*1000,x);
xlabel('t en ms');
ylabel('x(t)');
figure()
plot(t_k*1000,k)
xlabel('t_k en ms');
ylabel('k(t_k)');

%% Muestreo
%% Apartado a)
% 
% Frecuencia de muestreo [muestras/segundo] = (tiempo que dura la señal/numero de muestras)^-1

f_s = (max(t)/size(x,1))^-1;

%% Apartado b)
% 
% El teorema de Nyquist nos indica que, para que no haya interferencia
% intersimbólica al muestrear, la frecuencia de muestreo debe ser mayor o
% igual a dos veces el ancho de banda de la señal.
% 
% Para sacar el ancho de banda de la señal, realizamos la transformada de
% Fourier de dicha señal y la representamos. Para ello también debemos
% generar un vector de frecuencias. Una vez ya respresentado el espectro de
% la señal, podemos obtener la máxima componente en frecuencia.
% 
% De la grafica sacamos ancho de banda = 20.5 KHz
% 

X = (fft(x,length(x)))/length(x);
f_x = linspace(-f_s/2,f_s/2,length(X));
figure()
plot(f_x/1000,fftshift(abs(X)));
xlabel('Frecuencia en KHz');
ylabel('X(f)');
f_n = 2*20500;
   
%% Apartado c)
% 
% En este apartado cambiaremos al frecuencia de muestreo a tres medios la
% frecuencia mínima (la obtenida por el teoríma de Nyquist en el apartado
% anterior). Para muestrear la señal a esta nueva frecuencia, utilizaremos
% la funcion interp1.
% 
% Al representar gráficamente podemos observar que el espectro de la señal
% con esta nueva frecuencia de muestreo, es la misma que la original. Esto
% se debe a que no incumplimos el teorema de Nyquist.

fs1 = (3*f_n)/2;
t1 = t(1):1/fs1:t(end);
g = interp1(t,x,t1,'spline');

G = (fft(g,length(g)))/length(g);
f_g = linspace(-fs1/2,fs1/2,length(G));
figure()
plot(f_g/1000,fftshift(abs(G)));
xlabel('Frecuencia en KHz');
ylabel('G(f)');


%% Apartado d)
% 
% En este apartado repetiremos el procedimiento del apartado c). Esta vez
% la frecuencia de muestreo será dos tercios de la frecuencia de Nyquist.
% 
% Antes de calcular nada, podríamos decir firmemente que la señal
% muestreada no será la misma que la original, ya que no comple el teorema
% de Nyquist.
% 
% Como se puede observar, el espectro de esta señal no es equivalente al de
% la original. Esto se debe a que se produce Aliasing, ya que no hemos
% cumplido el teorema de Nyquist.

fs2 = (2*f_n)/3;
t2 = t(1):1/fs2:t(end);
h = interp1(t,x,t2,'spline');

H = (fft(h,length(h)))/length(h);
f_h = linspace(-fs2/2,fs2/2,length(H));
figure()
plot(f_h/1000,fftshift(abs(H)));
xlabel('Frecuencia en KHz');
ylabel('H(f)');
%% Apartado e)
% 
% Vamos a emplear un subplot para representar los espectros de la señal
% original y las dos señales con las frecuencias de muestreo cambiadas. Se
% puede ver claramente en la última, que al no cumplir el teorema de
% Nyquist, no obtenemos la misma señal.

figure()
subplot(3,1,1);
plot(f_x/1000,fftshift(abs(X)));
hold on
xlabel('frecuencia en KHz');
ylabel('X(f)');
xlim([-30 30]);
subplot(3,1,2);
plot(f_g/1000,fftshift(abs(G)));
xlabel('frecuencia en KHz');
ylabel('G(f)');
xlim([-30 30]);
subplot(3,1,3);
plot(f_h/1000,fftshift(abs(H)));
xlabel('frecuencia en KHz');
ylabel('H(f)');
xlim([-30 30]);

%% Apartado f)
% 
% Se puede observar una leve potencia a lo largo del espectro. Esto se debe
% a que hay ruido presente en el sistema. Se ve sobre todo ruido entre las
% componentes de la tercera gráfica. Tambien hay ruido intersimbólico
% (presente en la tercera gráfica) y de interpolación, presente en todas
% las señales. Este último se debe a que, al tener datos discretos de las
% señales, al hacer el plot, hay una interpolación.

%% Apartado g)
% 
% Una vez más, se puede ver que la tercera señal, no se puede recuperar la
% misma información que la señal original debido al Aliasing.
% 
figure()
subplot(3,1,1)
plot(t*1000,x);
hold on
xlabel('tiempo en ms')
ylabel('x(t)')
subplot(3,1,2);
plot(t1*1000,g);
hold on
xlabel('tiempo en ms')
ylabel('g(t)')
subplot(3,1,3);
plot(t2*1000,h);
hold on
xlabel('tiempo en ms')
ylabel('h(t)')

%% Cuantificacion
%% Apartado a)
% 
% Los niveles de cuantificación totales son 2^(B), siendo este número el
% numero el máximo de combinaciones disponibles con B bits totales (signo,
% enteros y decimales).

%% Apartado b)
%
% La magnitud del salto entre dos niveles de cuantificación consecutivos es
% 1/(2^D), siendo esta la distancia entre dos niveles de cuantificación de
% la parte decimal D, puesto que es el mínimo salto consecutivo posible
% (entre dos bits enteros hay 2^D bitsdecimales).
 
%% Apartado c)
%
% El rango de cuantificación máximo es de [-2^(B-D),(2^D)-1] hasta 
% [2^(B-D-1)-1, (2^D)-1], siendo B el número total de bits, D bits
% decimales y B-D bits enteros, y teniendo en cuenta en el rango que los
% bits enteros tienen signo, pero los decimales no tienen signo.

%%  Apartado d)
% 
% Minimo error = 0. (suponemos que no se comete ningún error)
% Maximo error = 1/2^D*2= 1/2^(D+1, ya que el mayor error cometido es
% cuando se cuantifica en medio de un nivel de cuantificación
% (DistanciaEntre2NivelesConsecutivos/2).

%% Apartado e)
%
% Usando las fórmulas obtenidas, para B=5 y D=3:
% Niveles de cuantificación: 32
% Salto entre niveles: 1/16
% Nivel Max: -4,7 REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH Nivel minimo: 1,7
% Rango de Error: (0 - 1/32)

%% Apartado f)
%
% Se cuantifica utilizando la fórmulas del enunciado palabras con B=4 (1 bit
% de signo, 3 bits enteros y 0 bits decimales) y D=0.
% Primero se genera la escala de cuantificación y posteriormente se
% cuantifica la señal k(t) que se facilita en la práctica.

q1 = quantizer('fixed','round','saturate',[4,0]);
Ks30 = num2bin(q1,k);
    
%% Apartado g)
%
% Se repite el mismo proceso esta vez con B=4 (1 bit de signo, 1 bit entero
% y 2 bits decimales) y D=2.

q2 = quantizer('fixed','round','saturate',[4,2]);
Ks12 = num2bin(q2,k);
    
%% Apartado h)
%
% Se repite el mismo proceso esta vez con B=6 (1 bit de signo, 3 bits
% enteros y 2 bits decimales) y D=2.

q3 = quantizer('fixed','round','saturate',[6,2]);
Ks32 = num2bin(q3,k);
    
%% Apartado i)
%
% Se repite el mismo proceso esta vez con B=6 (1 bit de signo, 5 bits
% enteros y 0 bits decimales) y D=0.

q4 = quantizer('fixed','round','saturate',[6,0]);
Ks50 = num2bin(q4,k);
    
 %% Apartado j)
%
% Se analiza en el dominio del tiempo las diferencias entre la señal
% original y las señales cuantificadas como valores decimales (ya que los
% valores binarios tienen que tener una interpretación decimal para ser
% válidos). Para las señales cuantificadas en valor decimal se nos
% facilita una función.
% 
% En la representación temporal de las señales se observan ligeras 
% diferencias. En concreto se puede ver muy claramente que la señal Ks12
% se parece a la señal original.

figure()
subplot(5,1,1)
plot(t_k,k);
hold on
xlabel('tiempo en ms')
ylabel('k(t)')

subplot(5,1,2)
plot(t_k,bin2num(q1,Ks30));
hold on
xlabel('tiempo en ms')
ylabel('ks30(t)')

subplot(5,1,3)
plot(t_k,bin2num(q2,Ks12));
hold on
xlabel('tiempo en ms')
ylabel('ks12(t)')

subplot(5,1,4)
plot(t_k,bin2num(q3,Ks32));
hold on
xlabel('tiempo en ms')
ylabel('ks32(t)')

subplot(5,1,5)
plot(t_k,bin2num(q4,Ks50));
hold on
xlabel('tiempo en ms')
ylabel('ks50(t)')

%% Apartado k)
%
% Se pretende calcular el error cuadrático medio (ECM) cometido en cada
% cuantificación de las distintas señales, para facilitar la operación se
% ha creado la función ECM en un fichero aparte, al cual se le llama desde
% el main principal y muestra por pantalla el ECM de cada señal
% cuantificada con respecto a la original. 
%
% La función ECM recibe como parámetros k original y KsXX cuantificada para
% cada apartado anterior, y devuelve el valor del ECM. Igual que vimos en
% las graficas, la funcion nos indica que Ks12 tiene una tasa de error muy
% superior al resto.

% error Ks30

disp('Error Ks30');
disp(ECM(k,bin2num(q1,Ks30)));

% error Ks12

disp('Error Ks12');
disp(ECM(k,bin2num(q2,Ks12)));

% error Ks32

disp('Error Ks32');
disp(ECM(k,bin2num(q3,Ks32)));

% error Ks50

disp('Error Ks50');
disp(ECM(k,bin2num(q4,Ks50)));

%% Apartado l)
%
% Se pretende analizar el espectro de la señal original y dos de sus
% señales cuantificadas (tras pasar los valores binarios a decimales para
% su representación). Inicialmente calculamos la frecuencia de muestreo
% correspondiente para acotar el eje de frecuencias y calculamos los
% módulos de las transformadas de Fourier de las señales en cuestión.
% 
% Por último, volvemos a hacer incapié en como al cuantificar se produce un
% error. En la señal Ks30 se observa un error pero leve. Sin embargo, se
% puede observar que el espectro de Ks12 es muy distinto al original.
%
% Los picos que se pueden observar a lo largo del espectro (los que no
% aparecen en la señal original), se deben a errores en la cuantificación.

f_sk = (max(t_k)/size(k,1))^-1;
K = (fft(k,length(k)))/length(k);
f_k = linspace(-f_sk/2,f_sk/2,length(K));
Ks30f = (fft(bin2num(q1,Ks30),length(bin2num(q1,Ks30))))/length(bin2num(q1,Ks30));
Ks12f = (fft(bin2num(q2,Ks12),length(bin2num(q2,Ks12))))/length(bin2num(q2,Ks12));

figure()
subplot(3,1,1);
plot(f_k/1000,fftshift(abs(K)));
hold on
xlabel('frecuencia en Khz')
ylabel('|K(f)|')
subplot(3,1,2);
plot(f_k/1000,fftshift(abs(Ks30f)));
hold on
xlabel('frecuencia en Khz')
ylabel('|Ks30(f)|')
subplot(3,1,3);
plot(f_k/1000,fftshift(abs(Ks12f)));
hold on
xlabel('frecuencia en Khz')
ylabel('|Ks12(f)|')

##### SOURCE END #####
--></body></html>