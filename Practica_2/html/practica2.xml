<?xml version="1.0" encoding="utf-8"?>
<mscript xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <version>9.7</version>
   <release>2019b</release>
   <date>2020-02-21</date>
   <cell style="overview">
      <count>1</count>
      <steptitle style="document">Práctica 2</steptitle>
      <text>
         <p>Teresa González y Miguel Oleo</p>
      </text>
      <cellOutputTarget>1</cellOutputTarget>
   </cell>
   <cell>
      <count>2</count>
      <steptitle>Conceptos de las señales de audio</steptitle>
      <cellOutputTarget>2</cellOutputTarget>
   </cell>
   <cell>
      <count>3</count>
      <steptitle>Apartado a)</steptitle>
      <mcode>[Xn, fs] = audioread('PDS_P3_LE1_G3.wav');
sound(Xn,fs);</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">[Xn, fs] = audioread(<mwsh:strings xml:space="preserve">'PDS_P3_LE1_G3.wav'</mwsh:strings>);
sound(Xn,fs);</mwsh:code>
      </mcode-xmlized>
      <mcode-count>1</mcode-count>
      <cellOutputTarget>3</cellOutputTarget>
   </cell>
   <cell>
      <count>4</count>
      <steptitle>Apartado b)</steptitle>
      <text>
         <p>Creamos el vector de tiempos, empezando en 0 y representamos la señal Xn</p>
      </text>
      <mcode>dt = 1/fs;
t= 0:dt:((length(Xn)-1)/fs);
figure();
plot(t,Xn)
title('Señal de audio original')
xlabel('Tiempo en segundos')
ylabel('Xn(t)')</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">dt = 1/fs;
t= 0:dt:((length(Xn)-1)/fs);
figure();
plot(t,Xn)
title(<mwsh:strings xml:space="preserve">'Señal de audio original'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Xn(t)'</mwsh:strings>)</mwsh:code>
      </mcode-xmlized>
      <mcode-count>2</mcode-count>
      <cellOutputTarget>4</cellOutputTarget>
      <img src="practica2_01.png"/>
   </cell>
   <cell>
      <count>5</count>
      <steptitle>Apartado c)</steptitle>
      <text>
         <p>La señal es simétrica, con respecto a 0. Además, la gran mayoría de puntos se encuentran concentrados en torno al valor medio de la señal (que es aproximadamente 0)</p>
      </text>
      <cellOutputTarget>5</cellOutputTarget>
   </cell>
   <cell>
      <count>6</count>
      <steptitle>Apartado d)</steptitle>
      <text>
         <p>A partir de la gráfica del apartado b), podemos observar que al principio y al final, no hay señal (solo ruido). Para quitarlo, procedemos a poner los valores de Xn(t) anteriores a 0.14 segundos a 0, y lo mismo con los tiempos posteriores a 3.43.</p>
      </text>
      <mcode>Yn = Xn;
index1 = find(t &lt;= 0.1423);
index2 = find(t &gt;= 3.43);
Yn(index1)=0;
Yn(index2)=0;

figure;
plot(t,Yn)
title('Señal limpiada Yn')
xlabel('Tiempo en segundos')
ylabel('Yn(t)')</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">Yn = Xn;
index1 = find(t &lt;= 0.1423);
index2 = find(t &gt;= 3.43);
Yn(index1)=0;
Yn(index2)=0;

figure;
plot(t,Yn)
title(<mwsh:strings xml:space="preserve">'Señal limpiada Yn'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Yn(t)'</mwsh:strings>)</mwsh:code>
      </mcode-xmlized>
      <mcode-count>3</mcode-count>
      <cellOutputTarget>6</cellOutputTarget>
      <img src="practica2_02.png"/>
   </cell>
   <cell>
      <count>7</count>
      <steptitle>Apartado e)</steptitle>
      <text>
         <p>Calculamos la transformada de Fourier de la señal anterior y representamos su espectro en el margen de frecuencias de interes.</p>
      </text>
      <mcode>Yf = (fft(Yn,length(Yn)))/length(Yn);
f_y = linspace(-fs/2,fs/2,length(Yn));
figure();
plot(f_y/1000,fftshift(abs(Yf)));
title('Transformada de Fourier de Yn')
xlabel('Frecuencia en KHz')
ylabel('|Yn(f)|')</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">Yf = (fft(Yn,length(Yn)))/length(Yn);
f_y = linspace(-fs/2,fs/2,length(Yn));
figure();
plot(f_y/1000,fftshift(abs(Yf)));
title(<mwsh:strings xml:space="preserve">'Transformada de Fourier de Yn'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Frecuencia en KHz'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'|Yn(f)|'</mwsh:strings>)</mwsh:code>
      </mcode-xmlized>
      <mcode-count>4</mcode-count>
      <cellOutputTarget>7</cellOutputTarget>
      <img src="practica2_03.png"/>
   </cell>
   <cell>
      <count>8</count>
      <steptitle>Apartado f)</steptitle>
      <text>
         <p>Como se puede observar en la transformada de Fourier, la mayores amplitudes se encuentran en frecuencias próximas a cero. Por ello, es donde más energía se concentra.</p>
         <p>Es una representación que no muestra la energía que contienen los armónicos según va variando la señal. Debido a esto, recomendamos representarla mediante un espectrograma, ya que muestra lo anterior.</p>
      </text>
      <cellOutputTarget>8</cellOutputTarget>
   </cell>
   <cell>
      <count>9</count>
      <steptitle>Apartado g)</steptitle>
      <text>
         <p>Representamos un histograma que muestre los valores de amplitud de cada muestra de la señal Yn.</p>
         <p>Viendo esta gráfica, se reafirma que la mayor parte de muestras, tienen amplitud cercana a cero.</p>
      </text>
      <mcode>figure()
histogram(Yn,100);
title('Histograma de Yn')
xlabel('Amplitud divida en rangos')
ylabel('Frecuencia estadística')</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">figure()
histogram(Yn,100);
title(<mwsh:strings xml:space="preserve">'Histograma de Yn'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Amplitud divida en rangos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Frecuencia estadística'</mwsh:strings>)</mwsh:code>
      </mcode-xmlized>
      <mcode-count>5</mcode-count>
      <cellOutputTarget>9</cellOutputTarget>
      <img src="practica2_04.png"/>
   </cell>
   <cell>
      <count>10</count>
      <steptitle>Apartado h)</steptitle>
      <text>
         <p>Representación en diagrama de cajas de la señal limpiada (Yn). Se puede observar que el rango intercuartílico no es muy amplio, por lo que volvemos, otra vez, a verificar que la gran mayoría de muestrás están muy concentradas en torno a la mediana. La media y mediana se puede observar que es próximo a cero. También cabe destacar que se muestran muchos datos atípicos.</p>
      </text>
      <mcode>figure()
boxplot(Yn);
title('Boxplot de Yn')
ylabel('Amplitud')</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">figure()
boxplot(Yn);
title(<mwsh:strings xml:space="preserve">'Boxplot de Yn'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Amplitud'</mwsh:strings>)</mwsh:code>
      </mcode-xmlized>
      <mcode-count>6</mcode-count>
      <cellOutputTarget>10</cellOutputTarget>
      <img src="practica2_05.png"/>
   </cell>
   <cell>
      <count>11</count>
      <steptitle>Apartado i)</steptitle>
      <text>
         <p>A continuación se muestran los datos estadísticos más relevantes:</p>
      </text>
      <mcode>disp('Media de Yn: ')
media = mean(Yn)

disp('Mediana de Yn: ')
mediana = median(Yn)

disp('Desviación típica de Yn: ')
desv_tip = std(Yn)</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">disp(<mwsh:strings xml:space="preserve">'Media de Yn: '</mwsh:strings>)
media = mean(Yn)

disp(<mwsh:strings xml:space="preserve">'Mediana de Yn: '</mwsh:strings>)
mediana = median(Yn)

disp(<mwsh:strings xml:space="preserve">'Desviación típica de Yn: '</mwsh:strings>)
desv_tip = std(Yn)</mwsh:code>
      </mcode-xmlized>
      <mcode-count>7</mcode-count>
      <cellOutputTarget>11</cellOutputTarget>
      <mcodeoutput class="codeoutput">Media de Yn: 

media =

  -4.7867e-05

Mediana de Yn: 

mediana =

     0

Desviación típica de Yn: 

desv_tip =

    0.1251

</mcodeoutput>
   </cell>
   <cell>
      <count>12</count>
      <steptitle>Apartado j)</steptitle>
      <text>
         <p>La gran mayoria de datos están muy concentrados respescto de la media (aprox cero). Esto confirma que la gran mayoría de las muestás tienen una amplitud pequeña.</p>
      </text>
      <cellOutputTarget>12</cellOutputTarget>
   </cell>
   <cell>
      <count>13</count>
      <steptitle>Cuantificación uniforme</steptitle>
      <cellOutputTarget>13</cellOutputTarget>
   </cell>
   <cell>
      <count>14</count>
      <steptitle>Apartado a)</steptitle>
      <text>
         <p>Aplicamos el cuantificador, tal y como lo hicimos en la prácctica anterior.</p>
      </text>
      <mcode>q1 = quantizer('fixed','round','saturate',[7,5]);
Yq = num2bin(q1,Yn);
figure();
plot(t,bin2num(q1,Yq))
title('Yn cuantificada uniformemente')
xlabel('Tiempo en segundos')
ylabel('Yq(t)')</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">q1 = quantizer(<mwsh:strings xml:space="preserve">'fixed'</mwsh:strings>,<mwsh:strings xml:space="preserve">'round'</mwsh:strings>,<mwsh:strings xml:space="preserve">'saturate'</mwsh:strings>,[7,5]);
Yq = num2bin(q1,Yn);
figure();
plot(t,bin2num(q1,Yq))
title(<mwsh:strings xml:space="preserve">'Yn cuantificada uniformemente'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Yq(t)'</mwsh:strings>)</mwsh:code>
      </mcode-xmlized>
      <mcode-count>8</mcode-count>
      <cellOutputTarget>14</cellOutputTarget>
      <img src="practica2_06.png"/>
   </cell>
   <cell>
      <count>15</count>
      <steptitle>Apartado b)</steptitle>
      <text>
         <p>Hemos escogido 5 bits decimales, uno entero y otro de signo (ya que la señal va de -1 a 1, por lo que nos hace falta el signo y un digito entero)</p>
      </text>
      <cellOutputTarget>15</cellOutputTarget>
   </cell>
   <cell>
      <count>16</count>
      <steptitle>Cuantificación no uniforme</steptitle>
      <text>
         <p>Utilizamos cuantificación no uniforme para mejorar la precisión de nuestra señal cuantificada, ya que en amplitudes pequeñas (la gran mayoría de nuestra señal)los intervalos de cuantificación se hacen más estrechos para amplitudes bajas.</p>
      </text>
      <mcode>A = 87.6;</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">A = 87.6;</mwsh:code>
      </mcode-xmlized>
      <mcode-count>9</mcode-count>
      <cellOutputTarget>16</cellOutputTarget>
   </cell>
   <cell>
      <count>17</count>
      <steptitle>Apartado a, b y c)</steptitle>
      <text>
         <p>Hemos implementado el compresor y expansor en una función de Matlab aparte. Como argumentos de entrada recibe primero A (que la hemos fijado anteriormente en el "main") y luego recibe la señal que queremos comprimir. En el expansor, tiene los mismos arguumentos que el compresor.</p>
         <p>Para caracterizar estos bloques y apreciar mejor su funcionamiento, creamos un vector de -1:1 y se los pasamos a las funciones. En los plots, se puede ver como en el expansor, las amplitudes cercanas a 0 (eje y), acaparan más rango de amplitud. Sin embargo, el expansor hace todo lo contario, los valores próximos a cero abarcan muy poco rango de amplitud.</p>
         <p>Por último se muestra un subplot con la señal original y la señal comprimida y expandida. En esta gráfica se puede observar con más facilidad, cómo las amplitudes pequeñas de la señal original, en el compresor, se han expandido, y en el expansor se han comprimido.</p>
         <p>Los nombres de estos bloques pueden ser algo liosos, pero las gráficas muestran fielmente su funcionamiento.</p>
      </text>
      <mcode>vect = linspace(-1,1,length(t));
figure()
subplot(2,1,1)
plot(t,compresor(A,vect));
title('Compresor vector -1:1')
xlabel('Tiempo en segundos')
ylabel('Amplitud')
subplot(2,1,2)
plot(t,expansor(A,vect));
title('Expansor vector -1:1')
xlabel('Tiempo en segundos')
ylabel('Amplitud')

figure()
subplot(3,1,1)
plot(t,Yn);
title('Señal original Yn')
xlabel('Tiempo en segundos')
ylabel('Yn(t)')
subplot(3,1,2)
plot(t,compresor(A,Yn));
title('Compresor señal Yn')
xlabel('Tiempo en segundos')
ylabel('Yn(t) comprimida')
subplot(3,1,3)
plot(t,expansor(A,Yn));
title('Expansor señal Yn')
xlabel('Tiempo en segundos')
ylabel('Yn(t) expandida')</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">vect = linspace(-1,1,length(t));
figure()
subplot(2,1,1)
plot(t,compresor(A,vect));
title(<mwsh:strings xml:space="preserve">'Compresor vector -1:1'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Amplitud'</mwsh:strings>)
subplot(2,1,2)
plot(t,expansor(A,vect));
title(<mwsh:strings xml:space="preserve">'Expansor vector -1:1'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Amplitud'</mwsh:strings>)

figure()
subplot(3,1,1)
plot(t,Yn);
title(<mwsh:strings xml:space="preserve">'Señal original Yn'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Yn(t)'</mwsh:strings>)
subplot(3,1,2)
plot(t,compresor(A,Yn));
title(<mwsh:strings xml:space="preserve">'Compresor señal Yn'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Yn(t) comprimida'</mwsh:strings>)
subplot(3,1,3)
plot(t,expansor(A,Yn));
title(<mwsh:strings xml:space="preserve">'Expansor señal Yn'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Yn(t) expandida'</mwsh:strings>)</mwsh:code>
      </mcode-xmlized>
      <mcode-count>10</mcode-count>
      <cellOutputTarget>17</cellOutputTarget>
      <img src="practica2_07.png"/>
      <img src="practica2_08.png"/>
   </cell>
   <cell>
      <count>18</count>
      <steptitle>Apartado d)</steptitle>
      <text>
         <p>Para cuantificar no uniformemente, primero pasamos la señal por el compresor, luego por el cuantificador uniforme y, por último, por el expansor.</p>
      </text>
      <mcode>Ycomp = compresor(A,Yn);
Ycuant = bin2num(q1,num2bin(q1,Ycomp));
Ynuni = expansor(A,Ycuant);
figure();
plot(t,Ynuni);
title('Cuantificación no unfirme')
ylabel('Ynuni(t)')
xlabel('Tiempo en segundos')</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">Ycomp = compresor(A,Yn);
Ycuant = bin2num(q1,num2bin(q1,Ycomp));
Ynuni = expansor(A,Ycuant);
figure();
plot(t,Ynuni);
title(<mwsh:strings xml:space="preserve">'Cuantificación no unfirme'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Ynuni(t)'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundos'</mwsh:strings>)</mwsh:code>
      </mcode-xmlized>
      <mcode-count>11</mcode-count>
      <cellOutputTarget>18</cellOutputTarget>
      <img src="practica2_09.png"/>
   </cell>
   <cell>
      <count>19</count>
      <steptitle>Analisis resultados</steptitle>
      <cellOutputTarget>19</cellOutputTarget>
   </cell>
   <cell>
      <count>20</count>
      <steptitle>Apartado a)</steptitle>
      <text>
         <p>Reproducimos las tres señales y podemos observar, que al cuantificar, se introduce un leve ruido de fondo (ruido de cuantificación). La señal cuantificada no uniformemente, es levemente más fiel a la señal original (se escucha menos ruido).</p>
      </text>
      <mcode>Yuni = bin2num(q1,Yq);
sound(Yn,fs);
sound(Yuni,fs);
sound(Ynuni,fs);</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">Yuni = bin2num(q1,Yq);
sound(Yn,fs);
sound(Yuni,fs);
sound(Ynuni,fs);</mwsh:code>
      </mcode-xmlized>
      <mcode-count>12</mcode-count>
      <cellOutputTarget>20</cellOutputTarget>
   </cell>
   <cell>
      <count>21</count>
      <steptitle>Apartado b)</steptitle>
      <text>
         <p>En la primera gráfica, hemos representado las tres señales por separado. Debido a esto, no se puede apreciar mucha diferencia hasta que no hacemos zoom. Por ello, en la siguiente gráfica hemos representado un pequño segmento de las señales y las hemos superpuesto. En esta última gráfica se puede apreciar muiy bien como funcionan los distintos codificadores. Es muy visible como el codificador uniforme no es capaz de distinguir niveles de amplitud pequeños, mientras que el no uniforme si los cuantifica con más precisión.</p>
         <p>Por último, la tercera gráfica es la misma que la segunda pero con una sección de señal con mayor amplitud. En esta, se puede observar como el detalle que se consigue al cuantificar entre no uniforme y uniforme en amplitudes mas altas, es similar.</p>
      </text>
      <mcode>figure();
subplot(3,1,1)
plot(t,Yn)
title('Señal original Yn')
xlabel('Tiempo en segundo')
ylabel('Yn(t)')
subplot(3,1,2)
plot(t,Yuni)
title('Señal cuantificada uniformemente Yuni')
xlabel('Tiempo en segundos')
ylabel('Yuni(t)')
subplot(3,1,3)
plot(t,Ynuni)
title('Señal cuantificada no uniformemente Ynuni')
xlabel('Tiempo en segundos')
ylabel('Ynuni(t)')

figure()
plot(t(14000:15000),Yn(14000:15000))
title('Comparativa amplitudes pequeñas')
xlabel('tiempo en segundos')
ylabel('Amplitud')
hold on
plot(t(14000:15000),Yuni(14000:15000))
hold on
plot(t(14000:15000),Ynuni(14000:15000))
legend('Original','Cuant. uniforme','Cuant. no uniforme')

figure()
plot(t(18000:20000),Yn(18000:20000))
title('Comparativa amplitudes grandes')
xlabel('tiempo en segundos')
ylabel('Amplitud')
hold on
plot(t(18000:20000),Yuni(18000:20000))
hold on
plot(t(18000:20000),Ynuni(18000:20000))
legend('Original','Cuant. uniforme','Cuant. no uniforme')</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">figure();
subplot(3,1,1)
plot(t,Yn)
title(<mwsh:strings xml:space="preserve">'Señal original Yn'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundo'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Yn(t)'</mwsh:strings>)
subplot(3,1,2)
plot(t,Yuni)
title(<mwsh:strings xml:space="preserve">'Señal cuantificada uniformemente Yuni'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Yuni(t)'</mwsh:strings>)
subplot(3,1,3)
plot(t,Ynuni)
title(<mwsh:strings xml:space="preserve">'Señal cuantificada no uniformemente Ynuni'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'Tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Ynuni(t)'</mwsh:strings>)

figure()
plot(t(14000:15000),Yn(14000:15000))
title(<mwsh:strings xml:space="preserve">'Comparativa amplitudes pequeñas'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Amplitud'</mwsh:strings>)
hold <mwsh:strings xml:space="preserve">on</mwsh:strings>
plot(t(14000:15000),Yuni(14000:15000))
hold <mwsh:strings xml:space="preserve">on</mwsh:strings>
plot(t(14000:15000),Ynuni(14000:15000))
legend(<mwsh:strings xml:space="preserve">'Original'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Cuant. uniforme'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Cuant. no uniforme'</mwsh:strings>)

figure()
plot(t(18000:20000),Yn(18000:20000))
title(<mwsh:strings xml:space="preserve">'Comparativa amplitudes grandes'</mwsh:strings>)
xlabel(<mwsh:strings xml:space="preserve">'tiempo en segundos'</mwsh:strings>)
ylabel(<mwsh:strings xml:space="preserve">'Amplitud'</mwsh:strings>)
hold <mwsh:strings xml:space="preserve">on</mwsh:strings>
plot(t(18000:20000),Yuni(18000:20000))
hold <mwsh:strings xml:space="preserve">on</mwsh:strings>
plot(t(18000:20000),Ynuni(18000:20000))
legend(<mwsh:strings xml:space="preserve">'Original'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Cuant. uniforme'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Cuant. no uniforme'</mwsh:strings>)</mwsh:code>
      </mcode-xmlized>
      <mcode-count>13</mcode-count>
      <cellOutputTarget>21</cellOutputTarget>
      <img src="practica2_10.png"/>
      <img src="practica2_11.png"/>
      <img src="practica2_12.png"/>
   </cell>
   <cell>
      <count>22</count>
      <steptitle>Apartado c)</steptitle>
      <text>
         <p>A continuación mostramos los resultados del error cuadrático medio de las señales cuantifiacas respecto de la señal original.</p>
         <p>Como nos esperábamos, la cuantificación no uniforme presenta una leve mejora en términos de error cuadrático medio.</p>
      </text>
      <mcode>disp('ECM con la señal Uniformemente cuantificada')
disp(ECM(Yn,Yuni))

disp('ECM con la señal no uniformemente cuantificada')
disp(ECM(Yn,Ynuni))</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">disp(<mwsh:strings xml:space="preserve">'ECM con la señal Uniformemente cuantificada'</mwsh:strings>)
disp(ECM(Yn,Yuni))

disp(<mwsh:strings xml:space="preserve">'ECM con la señal no uniformemente cuantificada'</mwsh:strings>)
disp(ECM(Yn,Ynuni))</mwsh:code>
      </mcode-xmlized>
      <mcode-count>14</mcode-count>
      <cellOutputTarget>22</cellOutputTarget>
      <mcodeoutput class="codeoutput">ECM con la señal Uniformemente cuantificada
   5.3038e-05

ECM con la señal no uniformemente cuantificada
   3.8466e-05

</mcodeoutput>
   </cell>
   <originalCode>%% Práctica 2&#xD;
% &#xD;
% Teresa González y Miguel Oleo&#xD;
%&#xD;
%% Conceptos de las señales de audio&#xD;
%% Apartado a)&#xD;
[Xn, fs] = audioread('PDS_P3_LE1_G3.wav');&#xD;
sound(Xn,fs);&#xD;
&#xD;
%% Apartado b)&#xD;
% &#xD;
% Creamos el vector de tiempos, empezando en 0 y representamos la señal Xn&#xD;
dt = 1/fs;&#xD;
t= 0:dt:((length(Xn)-1)/fs);&#xD;
figure();&#xD;
plot(t,Xn)&#xD;
title('Señal de audio original')&#xD;
xlabel('Tiempo en segundos')&#xD;
ylabel('Xn(t)')&#xD;
&#xD;
%% Apartado c)&#xD;
% &#xD;
% La señal es simétrica, con respecto a 0. Además, la gran mayoría de&#xD;
% puntos se encuentran concentrados en torno al valor medio de la señal&#xD;
% (que es aproximadamente 0)&#xD;
&#xD;
%% Apartado d)&#xD;
% &#xD;
% A partir de la gráfica del apartado b), podemos observar que al principio&#xD;
% y al final, no hay señal (solo ruido). Para quitarlo, procedemos a poner&#xD;
% los valores de Xn(t) anteriores a 0.14 segundos a 0, y lo mismo con los tiempos&#xD;
% posteriores a 3.43.&#xD;
&#xD;
Yn = Xn;&#xD;
index1 = find(t &lt;= 0.1423);&#xD;
index2 = find(t &gt;= 3.43);&#xD;
Yn(index1)=0;&#xD;
Yn(index2)=0;&#xD;
&#xD;
figure;&#xD;
plot(t,Yn)&#xD;
title('Señal limpiada Yn')&#xD;
xlabel('Tiempo en segundos')&#xD;
ylabel('Yn(t)')&#xD;
&#xD;
%% Apartado e)&#xD;
% &#xD;
% Calculamos la transformada de Fourier de la señal anterior y&#xD;
% representamos su espectro en el margen de frecuencias de interes.&#xD;
&#xD;
Yf = (fft(Yn,length(Yn)))/length(Yn);&#xD;
f_y = linspace(-fs/2,fs/2,length(Yn));&#xD;
figure();&#xD;
plot(f_y/1000,fftshift(abs(Yf)));&#xD;
title('Transformada de Fourier de Yn')&#xD;
xlabel('Frecuencia en KHz')&#xD;
ylabel('|Yn(f)|')&#xD;
&#xD;
%% Apartado f)&#xD;
% &#xD;
% Como se puede observar en la transformada de Fourier, la mayores&#xD;
% amplitudes se encuentran en frecuencias próximas a cero. Por ello, es donde más energía se concentra.&#xD;
% &#xD;
% Es una representación que no muestra la energía que contienen los&#xD;
% armónicos según va variando la señal. Debido a esto, recomendamos&#xD;
% representarla mediante un espectrograma, ya que muestra lo anterior.&#xD;
&#xD;
%% Apartado g)&#xD;
% &#xD;
% Representamos un histograma que muestre los valores de amplitud de cada&#xD;
% muestra de la señal Yn.&#xD;
% &#xD;
% Viendo esta gráfica, se reafirma que la mayor parte de muestras, tienen&#xD;
% amplitud cercana a cero.&#xD;
&#xD;
figure()&#xD;
histogram(Yn,100);&#xD;
title('Histograma de Yn')&#xD;
xlabel('Amplitud divida en rangos')&#xD;
ylabel('Frecuencia estadística')&#xD;
&#xD;
%% Apartado h)&#xD;
% &#xD;
% Representación en diagrama de cajas de la señal limpiada (Yn). Se puede&#xD;
% observar que el rango intercuartílico no es muy amplio, por lo que&#xD;
% volvemos, otra vez, a verificar que la gran mayoría de muestrás están muy&#xD;
% concentradas en torno a la mediana. La media y mediana se puede observar&#xD;
% que es próximo a cero. También cabe destacar que se muestran muchos datos atípicos.&#xD;
&#xD;
figure()&#xD;
boxplot(Yn);&#xD;
title('Boxplot de Yn')&#xD;
ylabel('Amplitud')&#xD;
&#xD;
%% Apartado i)&#xD;
% &#xD;
% A continuación se muestran los datos estadísticos más relevantes:&#xD;
&#xD;
disp('Media de Yn: ')&#xD;
media = mean(Yn)&#xD;
&#xD;
disp('Mediana de Yn: ')&#xD;
mediana = median(Yn)&#xD;
&#xD;
disp('Desviación típica de Yn: ')&#xD;
desv_tip = std(Yn)&#xD;
&#xD;
%% Apartado j)&#xD;
% &#xD;
% La gran mayoria de datos están muy concentrados respescto de la media&#xD;
% (aprox cero). Esto confirma que la gran mayoría de las muestás tienen una&#xD;
% amplitud pequeña.&#xD;
&#xD;
%% Cuantificación uniforme&#xD;
%% Apartado a)&#xD;
% &#xD;
% Aplicamos el cuantificador, tal y como lo hicimos en la prácctica&#xD;
% anterior.&#xD;
&#xD;
q1 = quantizer('fixed','round','saturate',[7,5]);&#xD;
Yq = num2bin(q1,Yn);&#xD;
figure();&#xD;
plot(t,bin2num(q1,Yq))&#xD;
title('Yn cuantificada uniformemente')&#xD;
xlabel('Tiempo en segundos')&#xD;
ylabel('Yq(t)')&#xD;
&#xD;
%% Apartado b)&#xD;
% &#xD;
% Hemos escogido 5 bits decimales, uno entero y otro de signo (ya que la señal&#xD;
% va de -1 a 1, por lo que nos hace falta el signo y un digito entero)&#xD;
&#xD;
%% Cuantificación no uniforme&#xD;
%&#xD;
% Utilizamos cuantificación no uniforme para mejorar la precisión de&#xD;
% nuestra señal cuantificada, ya que en amplitudes pequeñas (la gran&#xD;
% mayoría de nuestra señal)los intervalos de cuantificación se hacen&#xD;
% más estrechos para amplitudes bajas.&#xD;
&#xD;
A = 87.6;&#xD;
&#xD;
%% Apartado a, b y c)&#xD;
% &#xD;
% Hemos implementado el compresor y expansor en una función de Matlab aparte. Como argumentos de entrada&#xD;
% recibe primero A (que la hemos fijado anteriormente en el "main") y luego&#xD;
% recibe la señal que queremos comprimir. En el expansor, tiene los mismos&#xD;
% arguumentos que el compresor.&#xD;
% &#xD;
% Para caracterizar estos bloques y apreciar mejor su funcionamiento,&#xD;
% creamos un vector de -1:1 y se los pasamos a las funciones. En los plots,&#xD;
% se puede ver como en el expansor, las amplitudes cercanas a 0 (eje y),&#xD;
% acaparan más rango de amplitud. Sin embargo, el expansor hace todo lo&#xD;
% contario, los valores próximos a cero abarcan muy poco rango de amplitud.&#xD;
% &#xD;
% Por último se muestra un subplot con la señal original y la señal&#xD;
% comprimida y expandida. En esta gráfica se puede observar con más&#xD;
% facilidad, cómo las amplitudes pequeñas de la señal original, en el&#xD;
% compresor, se han expandido, y en el expansor se han comprimido.&#xD;
% &#xD;
% Los nombres de estos bloques pueden ser algo liosos, pero las gráficas&#xD;
% muestran fielmente su funcionamiento.&#xD;
&#xD;
vect = linspace(-1,1,length(t));&#xD;
figure()&#xD;
subplot(2,1,1)&#xD;
plot(t,compresor(A,vect));&#xD;
title('Compresor vector -1:1')&#xD;
xlabel('Tiempo en segundos')&#xD;
ylabel('Amplitud')&#xD;
subplot(2,1,2)&#xD;
plot(t,expansor(A,vect));&#xD;
title('Expansor vector -1:1')&#xD;
xlabel('Tiempo en segundos')&#xD;
ylabel('Amplitud')&#xD;
&#xD;
figure()&#xD;
subplot(3,1,1)&#xD;
plot(t,Yn);&#xD;
title('Señal original Yn')&#xD;
xlabel('Tiempo en segundos')&#xD;
ylabel('Yn(t)')&#xD;
subplot(3,1,2)&#xD;
plot(t,compresor(A,Yn));&#xD;
title('Compresor señal Yn')&#xD;
xlabel('Tiempo en segundos')&#xD;
ylabel('Yn(t) comprimida')&#xD;
subplot(3,1,3)&#xD;
plot(t,expansor(A,Yn));&#xD;
title('Expansor señal Yn')&#xD;
xlabel('Tiempo en segundos')&#xD;
ylabel('Yn(t) expandida')&#xD;
&#xD;
%% Apartado d)&#xD;
% &#xD;
% Para cuantificar no uniformemente, primero pasamos la señal por el&#xD;
% compresor, luego por el cuantificador uniforme y, por último, por el&#xD;
% expansor.&#xD;
&#xD;
Ycomp = compresor(A,Yn);&#xD;
Ycuant = bin2num(q1,num2bin(q1,Ycomp));&#xD;
Ynuni = expansor(A,Ycuant);&#xD;
figure();&#xD;
plot(t,Ynuni);&#xD;
title('Cuantificación no unfirme')&#xD;
ylabel('Ynuni(t)')&#xD;
xlabel('Tiempo en segundos')&#xD;
&#xD;
%% Analisis resultados&#xD;
%% Apartado a)&#xD;
% &#xD;
% Reproducimos las tres señales y podemos observar, que al cuantificar, se&#xD;
% introduce un leve ruido de fondo (ruido de cuantificación). La señal&#xD;
% cuantificada no uniformemente, es levemente más fiel a la señal original (se escucha menos ruido).&#xD;
&#xD;
Yuni = bin2num(q1,Yq);&#xD;
sound(Yn,fs);&#xD;
sound(Yuni,fs);&#xD;
sound(Ynuni,fs);&#xD;
&#xD;
%% Apartado b)&#xD;
% &#xD;
% En la primera gráfica, hemos representado las tres señales por separado.&#xD;
% Debido a esto, no se puede apreciar mucha diferencia hasta que no hacemos&#xD;
% zoom. Por ello, en la siguiente gráfica hemos representado un pequño&#xD;
% segmento de las señales y las hemos superpuesto. En esta última gráfica&#xD;
% se puede apreciar muiy bien como funcionan los distintos codificadores.&#xD;
% Es muy visible como el codificador uniforme no es capaz de distinguir&#xD;
% niveles de amplitud pequeños, mientras que el no uniforme si los&#xD;
% cuantifica con más precisión.&#xD;
% &#xD;
% Por último, la tercera gráfica es la misma que la segunda pero con una&#xD;
% sección de señal con mayor amplitud. En esta, se puede observar como el&#xD;
% detalle que se consigue al cuantificar entre no uniforme y uniforme en&#xD;
% amplitudes mas altas, es similar.&#xD;
&#xD;
figure();&#xD;
subplot(3,1,1)&#xD;
plot(t,Yn)&#xD;
title('Señal original Yn')&#xD;
xlabel('Tiempo en segundo')&#xD;
ylabel('Yn(t)')&#xD;
subplot(3,1,2)&#xD;
plot(t,Yuni)&#xD;
title('Señal cuantificada uniformemente Yuni')&#xD;
xlabel('Tiempo en segundos')&#xD;
ylabel('Yuni(t)')&#xD;
subplot(3,1,3)&#xD;
plot(t,Ynuni)&#xD;
title('Señal cuantificada no uniformemente Ynuni')&#xD;
xlabel('Tiempo en segundos')&#xD;
ylabel('Ynuni(t)')&#xD;
&#xD;
figure()&#xD;
plot(t(14000:15000),Yn(14000:15000))&#xD;
title('Comparativa amplitudes pequeñas')&#xD;
xlabel('tiempo en segundos')&#xD;
ylabel('Amplitud')&#xD;
hold on&#xD;
plot(t(14000:15000),Yuni(14000:15000))&#xD;
hold on&#xD;
plot(t(14000:15000),Ynuni(14000:15000))&#xD;
legend('Original','Cuant. uniforme','Cuant. no uniforme')&#xD;
&#xD;
figure()&#xD;
plot(t(18000:20000),Yn(18000:20000))&#xD;
title('Comparativa amplitudes grandes')&#xD;
xlabel('tiempo en segundos')&#xD;
ylabel('Amplitud')&#xD;
hold on&#xD;
plot(t(18000:20000),Yuni(18000:20000))&#xD;
hold on&#xD;
plot(t(18000:20000),Ynuni(18000:20000))&#xD;
legend('Original','Cuant. uniforme','Cuant. no uniforme')&#xD;
&#xD;
%% Apartado c)&#xD;
% &#xD;
% A continuación mostramos los resultados del error cuadrático medio de las&#xD;
% señales cuantifiacas respecto de la señal original.&#xD;
% &#xD;
% Como nos esperábamos, la cuantificación no uniforme presenta una leve&#xD;
% mejora en términos de error cuadrático medio.&#xD;
&#xD;
disp('ECM con la señal Uniformemente cuantificada')&#xD;
disp(ECM(Yn,Yuni))&#xD;
&#xD;
disp('ECM con la señal no uniformemente cuantificada')&#xD;
disp(ECM(Yn,Ynuni))&#xD;
&#xD;
&#xD;
&#xD;
    </originalCode>
   <m-file>practica2</m-file>
   <filename>C:\Users\oleob\OneDrive - Universidad Pontificia Comillas\ICAI_3GITT\PDS\Practica_2_corregida\practica2.m</filename>
   <outputdir>C:\Users\oleob\OneDrive - Universidad Pontificia Comillas\ICAI_3GITT\PDS\Practica_2_corregida\html</outputdir>
</mscript>